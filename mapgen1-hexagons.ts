/*!
 * From https://www.redblobgames.com/x/2543-mapgen1-hexagons/
 * Copyright 2025 Red Blob Games <redblobgames@gmail.com>
 * @license Apache-2.0 <https://www.apache.org/licenses/LICENSE-2.0.html>
 */

const MAP_RADIUS = 17; // number of hexes in each direction from center
const SHAPE_INTO_ISLAND = 0.4; // from 0.0 to 1.0

import { Point, Hex, Layout } from "./hexlib.js";
import { createNoise2D } from "./build/_libs.js";

function mod(a: number, b: number): number { return (a % b + b) % b; }
function lerp(a: number, b: number, t: number): number { return a * (1-t) + b * t; }

/** Represents an edge between two adjacent hexes
 */
class Edge {
    /**
     * @param {Hex} hex The starting hex tile.
     * @param {number} direction 0 to 5 representing which neighbor we're referring to.
     */
    constructor(public hex: Hex, public direction: number) {
        // Edges are bidirectional so we canonicalize, from directions 3,4,5 to
        // directions 0,1,2 from the adjacent neighbor:
        // https://www.redblobgames.com/grids/parts/#hexagon-coordinates
        direction = mod(direction, 6);
        if (direction >= 3) {
            hex = hex.neighbor(direction);
            direction -= 3;
        }
    }

    /** key used when we want to store a Map() of these */
    toString() {
        return `edge:${this.hex}:dir:${this.direction}`;
    }
}

// from https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes
function createHexagonShapedMap(radius: number): Set<Hex> {
    let results: Set<Hex> = new Set();
    for (let q = -radius; q <= radius; q++) {
        let r1 = Math.max(-radius, -q - radius);
        let r2 = Math.min(radius, -q + radius);
        for (let r = r1; r <= r2; r++) {
            results.add(new Hex(q, r));
        }
    }
    return results;
}

function fbm(noise2D, x: number, y: number, octaves: number): number {
    let frequency = 1.0;
    let amplitude = 1.0;
    let sumOfAmplitudes = 0.0;
    let sumOfNoise = 0.0;
    for (let layer = 0; layer < octaves; layer++, frequency *= 2.0, amplitude *= 0.5) {
        let v = noise2D(x * frequency + layer, y * frequency + layer);
        sumOfNoise += amplitude * v;
        sumOfAmplitudes += amplitude;
    }
    return sumOfNoise / sumOfAmplitudes;
}

// adapted from https://www.redblobgames.com/maps/mapgen2/
const BIOMES = {
    OCEAN: "#44447a",
    SNOW: "#ffffff",
    TUNDRA: "#bbbbaa",
    BARE: "#888888",
    SCORCHED: "#555555",
    TAIGA: "#99aa77",
    SHRUBLAND: "#889977",
    TEMPERATE_DESERT: "#c9d29b",
    TEMPERATE_RAIN_FOREST: "#448855",
    TEMPERATE_DECIDUOUS_FOREST: "#679459",
    GRASSLAND: "#88aa55",
    SUBTROPICAL_DESERT: "#d2b98b",
    TROPICAL_RAIN_FOREST: "#337755",
    TROPICAL_SEASONAL_FOREST: "#559944",
    // We can also add biomes that aren't generated by mapgen
    MARSH: "#2f6666",
    FOUNT: "hsl(300 50% 50%)",
    VOLCANO: "hsl(0 50% 25%)",
};
type BiomeString = keyof typeof BIOMES;

function biomeFor(elevation: number, moisture: number): BiomeString {
    let ocean = elevation < 0.0;
    let temperature = 1.0 - elevation;
    if (ocean) {
        return 'OCEAN';
    } else if (temperature < 0.2) {
        if (moisture > 0.50) return 'SNOW';
        else if (moisture > 0.33) return 'TUNDRA';
        else if (moisture > 0.16) return 'BARE';
        else return 'SCORCHED';
    } else if (temperature < 0.4) {
        if (moisture > 0.66) return 'TAIGA';
        else if (moisture > 0.33) return 'SHRUBLAND';
        else return 'TEMPERATE_DESERT';
    } else if (temperature < 0.7) {
        if (moisture > 0.83) return 'TEMPERATE_RAIN_FOREST';
        else if (moisture > 0.50) return 'TEMPERATE_DECIDUOUS_FOREST';
        else if (moisture > 0.16) return 'GRASSLAND';
        else return 'TEMPERATE_DESERT';
    } else {
        if (moisture > 0.66) return 'TROPICAL_RAIN_FOREST';
        else if (moisture > 0.33) return 'TROPICAL_SEASONAL_FOREST';
        else if (moisture > 0.16) return 'GRASSLAND';
        else return 'SUBTROPICAL_DESERT';
    }
}

// Adapted from https://www.redblobgames.com/x/2226-roguelike-dev/
// JavaScript Map keys are compared by identity, but I want them
// compared by toString() value, so I have this version of Map.
// Note that keys() will return the toString() versions, not the
// the original objects (which aren't unique)
class KeyMap<T extends Object, U> extends Map {
    override get(key: T): U        { return super.get(key.toString()); }
    override has(key: T): boolean  { return super.has(key.toString()); }
    override set(key: T, value: U) { return super.set(key.toString(), value); }
    override delete(key: T)        { return super.delete(key.toString()); }
}

// Store the set of tiles and edges, and their information.
//
// Map information can be of one of four types:
//  1. region attributes (forest, desert, ocean, etc.)
//  2. point attributes (village, volcano, statue, fount, etc.)
//  3. line attributes on the border between hexes (river, coastline, boundary)
//  4. line attributes crossing between hexes (road, trade route, bridge)
//
// These correspond to four elements of geometric algebra in 2
// dimensions, although amitp is not entirely sure if this is
// coincidence or destiny. Geometric algebra has:
//  1. e12 : 2-dimensional, representing areas
//  2. 1   : 0-dimensional, representing points
//  3. e1  : 1-dimensional, representing lines
//  4. e2  : 1-dimensional, representing lines orthogonal to the first set
//
// And here too we have these four types of data. Using duality we can use
// just two data types (Tile and Edge) to represent the four geometry types.
class GameMap {
    hexes: Set<Hex>;
    edges: Set<Edge>;
    hexesByID: Map<string, Hex>;

    elevation: KeyMap<Hex, number>;
    moisture: KeyMap<Hex, number>;
    biome: KeyMap<Hex, BiomeString>;
    coastline: KeyMap<Edge, boolean>;

    /**
     * @param {Set<Hex>} hexes - the set of hexes in this map
     */
    constructor(public radius: number) {
        this.hexes = createHexagonShapedMap(radius);
        this.hexesByID = new Map(Array.from(this.hexes, (hex) => [hex.id, hex]));
        this.edges = new Set();
        for (let hex of this.hexes) {
            for (let direction = 0; direction < 6; direction++) {
                this.edges.add(new Edge(hex, direction));
            }
        }

        this.elevation = new KeyMap();
        this.moisture = new KeyMap();
        this.biome = new KeyMap();
        this.coastline = new KeyMap();
    }

    generateElevations() {
        const scale = 0.5 / this.radius;
        let elevationNoise = createNoise2D();
        let moistureNoise = createNoise2D();
        let layout = new Layout(Layout.pointy, new Point(1, 1), new Point(0, 0));
        for (let hex of this.hexes) {
            let p = layout.hexToPixel(hex);
            let scaledX = p.x * scale,
                scaledY = p.y * scale;
            let e = fbm(elevationNoise, scaledX, scaledY, 4);
            let m = fbm(moistureNoise, scaledX, scaledY, 5);
            e = this.adjustElevationForIsland(hex.len() / this.radius, e);
            this.elevation.set(hex, e);
            this.moisture.set(hex, Math.abs(m));
        }
    }

    // adjust elevation to make it more of an island, adapted from
    // https://www.redblobgames.com/maps/terrain-from-noise/#islands
    adjustElevationForIsland(d, e) {
        e = lerp(e, 1 - 2 * d, SHAPE_INTO_ISLAND);
        return e;
    }

    generateBiomes() {
        for (let hex of this.hexes) {
            this.biome.set(hex, biomeFor(this.elevation.get(hex), this.moisture.get(hex)));
        }
    }
}


// Breadth first search, from one hex to all other hexes. Usage:
//
// let bfs = new BreadthFirstSearch((hex) => gameMap.hexesByID.has(hex.id) && gameMap.elevation.get(hex) > 0.0);
// bfs.searchFrom(start);
// let reachable = bfs.distanceTo.keys(); // this will be the IDs not the Hex objects themselves
// let distance = bfs.distanceTo.get(goal);
// let path = bfs.shortestPathTo(goal);
//
// The distances and paths are available for all goal nodes.
// Calling searchFrom() will reuse the data structures for the
// next search.
class BreadthFirstSearch {
    cameFrom: KeyMap<Hex, Hex | null>;
    distanceTo: KeyMap<Hex, number>;

    constructor(public isPassable: (hex) => boolean) {
        this.cameFrom = new KeyMap();
        this.distanceTo = new KeyMap();
    }

    // Fills the internal data structures, which can be queried afterwards
    searchFrom(start: Hex) {
        const {cameFrom, distanceTo, isPassable} = this;
        cameFrom.clear();
        distanceTo.clear();

        let currQueue: Array<Hex> = [];
        let nextQueue: Array<Hex> = [start];
        cameFrom.set(start, null);
        distanceTo.set(start, 0);

        for (let nextDistance = 1; nextQueue.length > 0; nextDistance++) {
            [currQueue, nextQueue] = [nextQueue, []];
            for (let curr of currQueue) {
                for (let dir = 0; dir < 6; dir++) {
                    let next = curr.neighbor(dir);
                    if (!isPassable(next)) continue;
                    if (cameFrom.has(next)) continue;
                    nextQueue.push(next);
                    cameFrom.set(next, curr);
                    distanceTo.set(next, nextDistance);
                }
            }
        }
    }

    // Ask for the shortest path from any hex to the one passed to searchFrom
    shortestPathTo(goal: Hex): Array<Hex> | null {
        const {cameFrom} = this;
        if (!cameFrom.has(goal)) return null;

        let path: Array<Hex> = [];
        let current: Hex | null = goal;
        while (current !== null) {
            path.push(current);
            current = cameFrom.get(current);
        }
        path.reverse();
        return path;
    }
}


// Drawing code
function drawHex(ctx, layout: Layout, hex: Hex, style: Object={}) {
    let corners = layout.polygonCorners(hex);
    ctx.beginPath();
    ctx.strokeStyle = "black";
    ctx.fillStyle = "white";
    ctx.lineWidth = 0.5;
    Object.assign(ctx, style);
    ctx.moveTo(corners[5].x, corners[5].y);
    for (let direction = 0; direction < 6; direction++) {
        ctx.lineTo(corners[direction].x, corners[direction].y);
    }
    ctx.fill();
    ctx.stroke();
}

function drawEdge(ctx, layout: Layout, edge: Edge, style: Object) {
    // TODO: for rivers, coastlines, roads
}


// NOTE: could be merged into GameMap; just depends on your coding style
class Renderer {
    canvas: HTMLCanvasElement;
    layout: Layout;

    constructor(id, public gameMap) {
        this.canvas = document.getElementById(id) as HTMLCanvasElement;
        this.layout = new Layout(
            Layout.pointy,
            new Point(this.canvas.width/gameMap.radius/3.6, this.canvas.height/gameMap.radius/3.6),
            new Point(this.canvas.width/2, this.canvas.height/2)
        );

        this.setUpPainter();
    }

    render() {
        let ctx = this.canvas.getContext('2d');
        for (let hex of this.gameMap.hexes) {
            let color = BIOMES[this.gameMap.biome.get(hex)];
            drawHex(ctx, this.layout, hex, {fillStyle: color});
        }

        /*
        let bfs = new BreadthFirstSearch((hex) => this.gameMap.hexesByID.has(hex.id) && this.gameMap.elevation.get(hex) > 0.0);
        bfs.searchFrom(new Hex(0, 0, 0));
        for (let hex of this.gameMap.hexes) {
            if (!bfs.distanceTo.has(hex)) continue;
            drawHex(ctx, this.layout, hex, {fillStyle: `hsl(${bfs.distanceTo.get(hex)*10} 50% 50%)`});
        }
         */
    }

    setUpPainter() {
        const tools = Object.keys(BIOMES);
        let toolbar = document.getElementById('toolbar');
        for (let tool of tools) {
            let label = document.createElement('label');
            label.style.backgroundColor = BIOMES[tool];
            label.style.color = tool === 'SNOW'? "black" : "white";
            let radio = document.createElement('input');
            radio.dataset.tool = tool;
            radio.setAttribute('type', "radio");
            radio.setAttribute('name', "tool");
            if (tool === 'OCEAN') radio.setAttribute('checked', "checked");
            label.innerText = tool;
            label.append(radio);
            toolbar!.append(label);
        }

        // adapted from https://www.redblobgames.com/making-of/draggable/examples.html#svg-painting

        let currentTool: null | string = null;

        const start = (event) => {
            if (event.button !== 0) return; // left button only
            currentTool = document.querySelector("#toolbar input:checked")!.dataset.tool;
            this.canvas.setPointerCapture(event.pointerId);
            move(event);
        };

        const end = (_event) => {
            currentTool = null;
        }

        const move = (event) => {
            if (!currentTool) return;

            const bounds = this.canvas.getBoundingClientRect();
            let x = (event.x - bounds.left) / bounds.width * this.canvas.width;
            let y = (event.y - bounds.top) / bounds.height * this.canvas.height;
            let hex = this.layout.pixelToHexRounded(new Point(x, y));
            let previousBiome = this.gameMap.biome.get(hex);
            if (previousBiome !== undefined && previousBiome !== currentTool) {
                this.gameMap.biome.set(hex, currentTool);
                this.render();
            }
        }

        this.canvas.addEventListener('pointerdown', start);
        this.canvas.addEventListener('pointerup', end);
        this.canvas.addEventListener('pointercancel', end);
        this.canvas.addEventListener('pointermove', move)
        this.canvas.addEventListener('touchstart', (e) => e.preventDefault()); // prevent scroll
    }
}

function main() {
    let gameMap = new GameMap(MAP_RADIUS);
    let renderer = new Renderer('output', gameMap);

    function redraw() {
        gameMap.generateElevations();
        gameMap.generateBiomes();
        renderer.render();
    }
    redraw();

    document.getElementById('regenerate')!.addEventListener('click', redraw);
}
main();
